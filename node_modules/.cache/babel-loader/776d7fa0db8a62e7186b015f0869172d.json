{"ast":null,"code":"import { warning } from 'hey-listen';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from './waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from './create-instant-animation.mjs';\nimport { animate } from './legacy-popmotion/index.mjs';\nimport { inertia } from './legacy-popmotion/inertia.mjs';\nimport { getDefaultTransition } from './utils/default-transitions.mjs';\nimport { isAnimatable } from './utils/is-animatable.mjs';\nimport { getKeyframes } from './utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from './utils/transitions.mjs';\nimport { supports } from './waapi/supports.mjs';\n/**\n * A list of values that can be hardware-accelerated.\n */\n\nconst acceleratedValues = new Set([\"opacity\"]);\n\nconst createMotionValueAnimation = function (valueName, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return onComplete => {\n    const valueTransition = getValueTransition(transition, valueName) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const keyframes = getKeyframes(value, valueName, target, valueTransition);\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n\n    const originKeyframe = keyframes[0];\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    let options = {\n      keyframes,\n      velocity: value.getVelocity(),\n      ...valueTransition,\n      elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    };\n\n    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {\n      /**\n       * If we can't animate this value, or the global instant animation flag is set,\n       * or this is simply defined as an instant transition, return an instant transition.\n       */\n      return createInstantAnimation(options);\n    } else if (valueTransition.type === \"inertia\") {\n      /**\n       * If this is an inertia animation, we currently don't support pre-generating\n       * keyframes for this as such it must always run on the main thread.\n       */\n      const animation = inertia(options);\n      return () => animation.stop();\n    }\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n\n\n    if (!isTransitionDefined(valueTransition)) {\n      options = { ...options,\n        ...getDefaultTransition(valueName, options)\n      };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n\n\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n\n    const visualElement = value.owner;\n    const element = visualElement && visualElement.current;\n    const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== \"mirror\" && options.damping !== 0 && typeof options.ease !== \"function\" && visualElement && element instanceof HTMLElement && !visualElement.getProps().onUpdate;\n\n    if (canAccelerateAnimation) {\n      /**\n       * If this animation is capable of being run via WAAPI, then do so.\n       */\n      return createAcceleratedAnimation(value, valueName, options);\n    } else {\n      /**\n       * Otherwise, fall back to the main thread.\n       */\n      const animation = animate(options);\n      return () => animation.stop();\n    }\n  };\n};\n\nexport { createMotionValueAnimation };","map":{"version":3,"names":["warning","secondsToMilliseconds","instantAnimationState","createAcceleratedAnimation","createInstantAnimation","animate","inertia","getDefaultTransition","isAnimatable","getKeyframes","getValueTransition","isTransitionDefined","supports","acceleratedValues","Set","createMotionValueAnimation","valueName","value","target","transition","onComplete","valueTransition","delay","elapsed","keyframes","originKeyframe","targetKeyframe","length","isOriginAnimatable","isTargetAnimatable","options","velocity","getVelocity","onUpdate","v","set","current","type","animation","stop","duration","repeatDelay","visualElement","owner","element","canAccelerateAnimation","waapi","has","repeatType","damping","ease","HTMLElement","getProps"],"sources":["C:/xampp/htdocs/om_react/node_modules/framer-motion/dist/es/animation/index.mjs"],"sourcesContent":["import { warning } from 'hey-listen';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from './waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from './create-instant-animation.mjs';\nimport { animate } from './legacy-popmotion/index.mjs';\nimport { inertia } from './legacy-popmotion/inertia.mjs';\nimport { getDefaultTransition } from './utils/default-transitions.mjs';\nimport { isAnimatable } from './utils/is-animatable.mjs';\nimport { getKeyframes } from './utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from './utils/transitions.mjs';\nimport { supports } from './waapi/supports.mjs';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\"]);\nconst createMotionValueAnimation = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(options);\n        }\n        else if (valueTransition.type === \"inertia\") {\n            /**\n             * If this is an inertia animation, we currently don't support pre-generating\n             * keyframes for this as such it must always run on the main thread.\n             */\n            const animation = inertia(options);\n            return () => animation.stop();\n        }\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        const visualElement = value.owner;\n        const element = visualElement && visualElement.current;\n        const canAccelerateAnimation = supports.waapi() &&\n            acceleratedValues.has(valueName) &&\n            !options.repeatDelay &&\n            options.repeatType !== \"mirror\" &&\n            options.damping !== 0 &&\n            typeof options.ease !== \"function\" &&\n            visualElement &&\n            element instanceof HTMLElement &&\n            !visualElement.getProps().onUpdate;\n        if (canAccelerateAnimation) {\n            /**\n             * If this animation is capable of being run via WAAPI, then do so.\n             */\n            return createAcceleratedAnimation(value, valueName, options);\n        }\n        else {\n            /**\n             * Otherwise, fall back to the main thread.\n             */\n            const animation = animate(options);\n            return () => animation.stop();\n        }\n    };\n};\n\nexport { createMotionValueAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}